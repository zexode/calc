def calc(expression):
    # Словари для преобразования слов в числа и обратно
    units = {
        "ноль": 0, "один": 1, "два": 2, "три": 3, "четыре": 4,
        "пять": 5, "шесть": 6, "семь": 7, "восемь": 8, "девять": 9,
        "десять": 10, "одиннадцать": 11, "двенадцать": 12, "тринадцать": 13,
        "четырнадцать": 14, "пятнадцать": 15, "шестнадцать": 16,
        "семнадцать": 17, "восемнадцать": 18, "девятнадцать": 19
    }  # Словарь для единиц и чисел от 10 до 19 на русском языке и их числовых значений

    tens = {
        "двадцать": 20, "тридцать": 30, "сорок": 40, "пятьдесят": 50,
        "шестьдесят": 60, "семьдесят": 70, "восемьдесят": 80, "девяносто": 90
    }  # Словарь для десятков на русском языке и их числовых значений

    # Создаем обратные словари для преобразования чисел в слова
    units_inv = {v: k for k, v in units.items()}  # Обратный словарь для единиц и чисел от 10 до 19
    tens_inv = {v: k for k, v in tens.items()}    # Обратный словарь для десятков
    expression = expression.replace("минус минус", "плюс")  # Заменяем двойное "минус" на "плюс" для упрощения

    def words_to_number(words):
        # Преобразует строку из слов, представляющих числа, в целое число
        words = words.lower().split()  # Приводим строку к нижнему регистру и разбиваем на отдельные слова
        number = 0  # Инициализируем переменную для числа
        is_negative = False  # Флаг для проверки, является ли число отрицательным

        if words and words[0] == 'минус':  # Если первое слово — "минус"
            is_negative = True  # Устанавливаем флаг отрицательного числа
            words = words[1:]  # Удаляем "минус" из списка слов

        if not words:  # Если после удаления "минус" строка пустая
            raise ValueError("Пустая строка")  # Выбрасываем ошибку

        if len(words) == 1:  # Если слово одно, это может быть единица или десяток
            word = words[0]  # Получаем это слово
            if word in units:  # Если слово в словаре units
                number = units[word]  # Присваиваем числовое значение
            elif word in tens:  # Если слово в словаре tens
                number = tens[word]  # Присваиваем числовое значение
            else:  # Если слово не распознано
                raise ValueError(f"Неизвестное число {word}")  # Выбрасываем ошибку
        elif len(words) == 2:  # Если два слова, это может быть десяток и единица
            if words[0] in tens and words[1] in units:  # Проверяем, что первое слово — десяток, а второе — единица
                number = tens[words[0]] + units[words[1]]  # Суммируем числовые значения десятка и единицы
            else:  # Если формат числа неверный
                raise ValueError(f"Некорректное число: {' '.join(words)}")  # Выбрасываем ошибку
        else:  # Если больше двух слов
            raise ValueError("Число должно состоять из одного или двух слов")  # Выбрасываем ошибку

        if is_negative:  # Если флаг отрицательного числа установлен
            number = -number  # Меняем знак на отрицательный

        return number  # Возвращаем числовое значение

    def number_to_words(number):
        # Преобразует целое число в строку из слов, представляющих это число
        if number == 0:  # Если число равно нулю
            return 'ноль'  # Возвращаем строку "ноль"

        if number < 0:  # Если число отрицательное
            return 'минус ' + number_to_words(-number)  # Возвращаем "минус" и рекурсивно обрабатываем положительное число

        words = []  # Инициализируем список для слов

        if number >= 20:  # Если число больше или равно 20
            tens_part = (number // 10) * 10  # Вычисляем десятки
            words.append(tens_inv[tens_part])  # Преобразуем десятки в слова и добавляем в список
            number %= 10  # Оставляем только единицы

        if 10 <= number <= 19:  # Если число от 10 до 19
            words.append(units_inv[number])  # Преобразуем число в слово и добавляем в список
            number = 0  # Обнуляем число, так как оно полностью обработано

        if 0 < number < 10:  # Если остались единицы
            words.append(units_inv[number])  # Преобразуем единицы в слово и добавляем в список

        return ' '.join(words)  # Объединяем список слов в строку и возвращаем

    def tokenize(expression):
        # Преобразует входное выражение в список токенов
        tokens = []  # Инициализируем список для токенов
        words = expression.lower().split()  # Приводим выражение к нижнему регистру и разбиваем на слова
        i = 0  # Инициализируем индекс для обхода по словам

        while i < len(words):  # Пока есть слова для обработки
            word = words[i]

            if word == 'скобка' and i + 1 < len(words):  # Если слово — "скобка" и за ним еще есть слово
                if words[i + 1] == 'открывается':  # Если следующее слово — "открывается"
                    tokens.append('(')  # Добавляем открывающую скобку
                    i += 2  # Пропускаем два слова
                    continue
                elif words[i + 1] == 'закрывается':  # Если следующее слово — "закрывается"
                    tokens.append(')')  # Добавляем закрывающую скобку
                    i += 2  # Пропускаем два слова
                    continue
            elif word == 'умножить' and i + 1 < len(words) and words[i + 1] == 'на':  # Если "умножить на"
                tokens.append('*')  # Добавляем оператор умножения
                i += 2  # Пропускаем два слова
                continue
            elif word == 'разделить' and i + 1 < len(words) and words[i + 1] == 'на':  # Если "разделить на"
                tokens.append('/')  # Добавляем оператор деления
                i += 2  # Пропускаем два слова
                continue
            elif word == 'в' and i + 1 < len(words) and words[i + 1] == 'степени':  # Если "в степени"
                tokens.append('^')  # Добавляем оператор возведения в степень
                i += 2  # Пропускаем два слова
                continue
            elif word == 'плюс':  # Если "плюс"
                tokens.append('+')  # Добавляем оператор сложения
                i += 1  # Переходим к следующему слову
                continue
            elif word == 'минус':  # Если "минус"
                tokens.append('-')  # Добавляем оператор вычитания
                i += 1  # Переходим к следующему слову
                continue
            else:
                num_words = []  # Инициализируем список для слов, представляющих число
                while i < len(words) and words[i] not in ['скобка', 'открывается', 'закрывается', 'плюс', 'минус', 'умножить', 'на', 'разделить', 'в', 'степени']:
                    num_words.append(words[i])  # Добавляем слово в список числа
                    i += 1
                num_str = ' '.join(num_words)  # Объединяем слова в строку
                number = words_to_number(num_str)  # Преобразуем слова в число
                tokens.append(number)  # Добавляем число в токены
        return tokens  # Возвращаем список токенов

    def evaluate(tokens):
        # Вычисляет выражение на основе токенов
        output_queue = []  # Инициализируем очередь вывода для ОПН
        operator_stack = []  # Инициализируем стек операторов для ОПН

        # Устанавливаем приоритеты и ассоциативность для каждого оператора
        precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}  # Приоритеты операторов
        associativity = {'+': 'L', '-': 'L', '*': 'L', '/': 'L', '^': 'R'}  # Ассоциативность операторов (лево- или правоассоциативные)

        i = 0  # Инициализируем индекс для обхода по токенам
        while i < len(tokens):  # Пока есть токены для обработки
            token = tokens[i]
            if isinstance(token, int):  # Если токен — число
                output_queue.append(token)  # Добавляем его в очередь вывода
            elif token in ['+', '-', '*', '/', '^']:  # Если токен — оператор
                while (operator_stack and operator_stack[-1] != '(' and
                       ((precedence[operator_stack[-1]] > precedence[token]) or
                        (precedence[operator_stack[-1]] == precedence[token] and associativity[token] == 'L'))):
                    output_queue.append(operator_stack.pop())  # Переносим операторы из стека в очередь вывода по приоритету
                operator_stack.append(token)  # Добавляем текущий оператор в стек
            elif token == '(':  # Если токен — открывающая скобка
                operator_stack.append(token)  # Добавляем её в стек
            elif token == ')':  # Если токен — закрывающая скобка
                while operator_stack and operator_stack[-1] != '(':  # Пока не найдём открывающую скобку
                    output_queue.append(operator_stack.pop())  # Переносим операторы в очередь вывода
                if operator_stack and operator_stack[-1] == '(':  # Если в стеке есть открывающая скобка
                    operator_stack.pop()  # Удаляем её из стека
                else:
                    raise ValueError("Несогласованные скобки")  # Ошибка, если нет открывающей скобки
            else:
                raise ValueError(f"Неизвестный токен {token}")  # Ошибка для неизвестного токена
            i += 1  # Переходим к следующему токену

        while operator_stack:  # После обработки всех токенов
            if operator_stack[-1] in ['(', ')']:  # Если остались скобки
                raise ValueError("Несогласованные скобки")  # Ошибка для несогласованных скобок
            output_queue.append(operator_stack.pop())  # Переносим оставшиеся операторы в очередь вывода

        stack = []  # Инициализируем стек для выполнения операций
        for token in output_queue:  # Обрабатываем каждый токен в ОПН
            if isinstance(token, int):  # Если токен — число
                stack.append(token)  # Добавляем его в стек
            elif token in ['+', '-', '*', '/', '^']:  # Если токен — оператор
                if len(stack) < 2:  # Проверяем, достаточно ли операндов для операции
                    raise ValueError("Недостаточно операндов")  # Ошибка, если недостаточно операндов
                b = stack.pop()  # Извлекаем правый операнд
                a = stack.pop()  # Извлекаем левый операнд
                if token == '+':  # Если оператор сложения
                    result = plus(a, b)
                elif token == '-':  # Если оператор вычитания
                    result = minus(a, b)
                elif token == '*':  # Если оператор умножения
                    result = multiply(a, b)
                elif token == '/':  # Если оператор деления
                    if b == 0:  # Проверяем деление на ноль
                        raise ValueError("Деление на ноль")
                    result = divide(a, b)
                elif token == '^':  # Если оператор возведения в степень
                    result = power(a, b)
                stack.append(result)  # Добавляем результат обратно в стек
            else:
                raise ValueError(f"Неизвестный токен {token}")  # Ошибка для неизвестного токена

        if len(stack) != 1:  # Проверяем, чтобы в стеке остался один элемент
            raise ValueError("Ошибка вычисления выражения")  # Ошибка, если больше одного элемента

        return stack[0]  # Возвращаем результат из стека

    def plus(x, y):
        return x + y  # Возвращает сумму x и y

    def minus(x, y):
        return x - y  # Возвращает разность x и y

    def multiply(x, y):
        return x * y  # Возвращает произведение x и y

    def divide(x, y):
        return x // y if x % y == 0 else x / y  # Возвращает целое деление или обычное, если есть остаток

    def power(x, y):
        return x ** y  # Возвращает x, возведённое в степень y

    expression = expression.lower().strip()  # Приводим выражение к нижнему регистру и удаляем лишние пробелы
    tokens = tokenize(expression)  # Токенизируем выражение
    result = evaluate(tokens)  # Вычисляем результат
    result_words = number_to_words(int(result)) if result == int(result) else str(result)  # Преобразуем результат в слова, если целое
    return result_words  # Возвращаем строковое представление результата

if __name__ == "__main__":
    while True:  # Бесконечный цикл для многократного ввода выражений
        user_input = input('Введите строковое выражение (или "стоп" для завершения): ')  # Запрашиваем выражение от пользователя
        if user_input.lower() == "стоп":  # Проверяем, если введено "стоп"
            print("Программа завершена.")  # Сообщаем о завершении программы
            break  # Прерываем цикл
        try:
            print(calc(user_input))  # Вызываем функцию calc и выводим результат
        except ValueError as e:  # Обрабатываем возможные ошибки
            print(f"Ошибка: {e}")  # Выводим сообщение об ошибке
